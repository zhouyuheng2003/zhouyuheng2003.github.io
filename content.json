{"posts":[{"title":"2023JLU_ACM招新面试","text":"吉林大学2023年ACM招新面试于2024年3月9日进行，本次面试采用现场问答题目的形式，目的在于考察同学的解题思路，以下为真题和解析。（题目选择与Hint设计：kingsnow） Codeforces 359B题意给定 $k$ 与 $n$ ，求一个长度为 $2n$ 的排列，满足： 保证 $(1 \\leq n \\leq 50000, 0 \\leq 2k \\leq n)$ Hint1可以先构造特殊情况。 Hint2可以尝试固定最左边这项的取值。 Hint3可以利用等式右边是2k而不是k的性质。 解法特殊情况，指的是 $k=0$时，此时取 $a_t=t$ 即可满足条件。 再考虑 $k\\neq 0$的情况，我们发现当调换 $a_{2i-1}$和 $a_{2i}$且已调换次数较少时，等式左侧的左边一项不变、右边一项会少2。 所以进行$k$次交换，即可构造出题目所需的排列。 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,k;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){ if(k){ k--; printf(&quot;%d %d &quot;,2*i,2*i-1); } else printf(&quot;%d %d &quot;,2*i-1,2*i); } return 0;} Codeforces 1541B题意给定$a_1$~$a_n$ ,保证$a_1$~$a_n$ 两两不同，求pair(i,j)满足 $i&lt;j$且$a_i*a_j=i+j$的对数。 保证$2≤n≤10^5,1≤ai≤2⋅n$ Hint1等式右边的值范围不大。 Hint2$\\sum_{i=1}^n \\frac1i =O(logn)$。 Hint3可先枚举$i$后枚举$i+j$。 解法先枚举$i$，得到$a_i$，那么$i+j$一定是$a_i$的倍数，又可知$i+j\\leq 2n$，所以可以一个一个枚举完$i+j$并验证$a_j$是否符合条件，总复杂度$O(nlogn)$ 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,n,a[100005];int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } int ans=0; for(int i=1;i&lt;=n;i++){ for(int sum=a[i];sum&lt;=2*n;sum+=a[i]){ int j=sum-i; if(j&lt;0||j&gt;n)continue; if(i==j)continue; if((ll)a[i]*a[j]!=sum)continue; ans++; } } printf(&quot;%d\\n&quot;,ans/2); } return 0;} Codeforces 1455B题意你站在坐标轴上的0点，第i次操作你可以选择坐标+i或-1，求到坐标x（x&gt;0）点的最小步数。共t次询问 保证$ 1≤t≤1000,1≤x≤10^6$ Hint1当固定总步数后，可以先走大的再走小的。 Hint2我们可以考虑先全+i，然后反悔 Hint3特殊情况，全取+i时到达了x+1的情况要特殊处理。 解法不断枚举步数，当全取+i时大于等于x了的时候停止。判特殊情况到达x+1，这种情况要加一步。其它情况将对应的步变成-1即可。 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,x;int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;x); int sum=0; for(int i=1;;i++){ sum+=i; if(sum&gt;=x){ if(sum==x+1)printf(&quot;%d\\n&quot;,i+1); else printf(&quot;%d\\n&quot;,i); break; } } } return 0;} Codeforces 1526B题意给x，求x能不能由11,111,1111，。。。，这些数相加得到（数可以重复使用）？共t次询问 保证$ 1≤t≤10000,1≤x≤10^9$ Hint1有些数用不上。 Hint2只有两个数能用上。 Hint3大的数用上的次数是很少的，可以求出来。 解法只有11和111能用上，而111用的次数不超过11次，所以可以直接枚举，或者取模都行。 代码1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,x;int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;x); int b=x%11; if(x&gt;=b*111)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0;}","link":"/2024/03/09/2023JLU_ACM%E6%8B%9B%E6%96%B0%E9%9D%A2%E8%AF%95/"},{"title":"2024上半年JLU_ACM讲题","text":"虽然临近退役，但是既然ACM队的训练需要讲题，还是得把这些题都码一遍，也顺便维持一下思维能力。 第三周训练_习题网址 A - Sasha and the Casino题目大意给定k,x,a，一次打赌赢了本金增加到k倍，输了清零，保证最多输x次，初始资金为a，问是否有策略使得在操作后金额任意大 解法考虑在本问题中，提供的条件不仅包含当前金额，还包含了已经连续输的次数，所以说，我们需要确保当赢了一次之后，金额比之前要高。又考虑到本金有限，所以应该在保证前一条件的情况下，尽可能降低金额的数值。所以在一段连续输后的下一次金额cur=max((cost+k-1)/(k-1),1)其中cost是这一段连续输花钱的总金额。 B - Equalize题目大意给定一个长度为n的数组，要求其与一个排列相加，使得出现次数最多的数的出现次数尽可能大，求这一最大值。 解法对所有数进行排序并去重，问题即变成求最大的满足最大数减最小数的差小于n的区间长度，可以用一个单调队列完成。 C - Physical Education Lesson题目大意1…k..1..k..1依次报数，已知位置n和报数的值x，求可能的k的数量 解法以1…k…2作为一个循环，已知n,x的情况下，循环要么在n-x要么在n+x-2,也有可能同时出现。这样2k-2肯定是循环结束位置的约数，枚举复杂度是根号的。此外还需要保证k不小于x。最后对于所有的k放set去重就可以了。 D - XOR-distance题目大意给定a,b,r，求|(a xor x)-(b xor x)|的最小值，其中$0\\leq x\\leq r$ 解法只需要考虑a,b不同的位，所以其它位都置为0，然后再取两个里大的数，令其最高位为不动，尽量使剩余位都变成0，在满足r的限制下贪心取就能解决此题。 E - A Balanced Problemset?题目大意给一个整数x，要求将x分成n个数的和，使得所有数的最大公因数最大，求这个最大的最大公因数 解法设最大公因数为k，那么k肯定是x的因数，且x/k不能小于x，枚举出满足条件的最大k即可。 F - Did We Get Everything Covered?题目大意给定字符串长度n和字符集k以及一个字符串s，问长度为n的字符集为k的字符串是否都是s的子序列，如果不是，请输出反例。 解法扫一遍，当凑齐一套字符集的字符后开始下一套，一共要n套，如果有责输出yes，不够则可以输出每套最后一个补全的字符和那个缺失的字符。 G - Partitioning the Array题目大意一个长度为$n$的数组a，划分成相等长度的k部分，问存在多少种k，存在m使得所有数模m后，每个部分都相同。 解法合法的k只有$sqrt(n)$个，对于每个k只需要判断是否存在m即可，而m的条件是任意位置相差k的数之差都是m的倍数，所以用gcd即可求得。 H - Watering an Array题目大意一个数组a，第i天可以给数组的前vi个数都加一，也可以选择收获ai=i个点数并清空数组a，其中vi是循环的。问d天后点数最多是多少。 解法容易发现清空数组a后，再收获的时候最多收获1，所以一旦清空最优策略就是加一收获来回进行。所以本题要考虑什么时候第一次收获，容易发现n不大，一次收获最多只有n，而一开始收获则只需要2n天就可以获得n，所以第一次收获一定不晚于2n。枚举时刻取最优就能解决此题。 I - Largest Subsequence题目大意一个字符串，每次选择字典序最大的子序列，将子序列对应位置的字符进行重排，原来最后一个字符到第一个字符的位置上，其它字符均向后移一个字符。问多少次操作，字符串变得有序。 解法考虑先求出最大的子序列（直接扫一遍），然后操作的结果即将这些字符翻转，花的步数即其中不是最大那个字符的字符数量。最后记得判断一下是否有序即可。 J - Array Game题目大意给你一个由$n$个正整数组成的数组$a$。在一次操作中，选取$(i,j)$，将$|a_i-a_j|$加到$a$ 的末尾。要求在执行$k$次操作后，最小化数组$a$的最小值。 解法如果k大于等于3，那么答案为0；如果k=0，答案为最小值；如果k=1，答案还需对差取min；如果k=2，那么答案还需要对两个数的和减去一个数的绝对值的最小值取min。 K - StORage room题目大意现在有一个n*n的表格M，是一把锁。锁的密码是一个长度为n的序列a，满足$M_{i,j}=a_i|a_j$ 解法对于一个a相关的所有要求都取与，再判断这个尽可能大的a是否满足所有条件即可 L - Theofanis’ Nightmare题目大意给定一个数组a,大小为n,现在将数组a分割成几个非空子数组,并且保证每个元素只在一个一个子数组中,例如，数组 [1,−3,7,−6,2,5]可以划分为 [1][−3,7][−6,2][5]。这种分割的值等于第i个子数组的和乘以i，再求和。求分割的最大值。 解法考虑一次划分后面的所有数贡献都加一，所以只需要找到大于等于0的后缀并且都加一即可，特判第一个位置。","link":"/2024/03/13/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4JLU_ACM%E8%AE%B2%E9%A2%98/"},{"title":"若干有趣的问题","text":"最近时常碰到一些有趣的问题，在这里记录一下我对这些问题的初步想法和在网上搜到的资料 OEISA004125问题背景2024.3.24:今天vp的时候碰到相关的题目分析复杂度时想到的。 问题简介一个正整数对小于等于自己当前值的正整数取模，结果的的期望是多少。该问题也就是求n分之一的下式：$$f(n)=\\sum_{i=1}^n (n\\bmod i)$$ 简单分析一次取模后，值不足原来的一半，所以有一个$\\frac{n^2}2$的上界；这个结论也可以通过余数不会大于除数而求和得到。 问题结论事实上，有一个等式把该问题进行转换：$$\\sum_{i=1}^n (n\\bmod i)=n^2-\\sum_{i=1}^n\\sigma(i)$$其中$\\sigma$是除数和函数。 这个式子证明大概可以按照如下思路，对于每个$(n\\bmod i)$，$i$作为除数出现在$i,2i,3i…$中，出现的次数恰好等于$\\left\\lfloor\\frac ni\\right\\rfloor$，这个次数乘以$i$后刚好等于$n$减去余数。 而除数和函数是积性函数，可以多项式复杂度内求解。 该数列本身的更多信息可参见oeis。 参考资料Jeffrey Shallit,Answer,2024.3.24 拓展问题一个正整数对小于等于自己当前值的正整数取模，需要多少次操作才能变成0 最坏情况每次$n_i$都对$\\left\\lceil \\frac{n_i+1}2\\right\\rceil$取模，当$n$处于$1$到$10^8$的范围内时，需要的次数大约在$1.4log_2(n)$左右。 期望情况根据该数列的信息，我猜测期望仍然是$O(log_2(n))$的。 OEISA003042问题背景2024-03-13：今天jwong学长和我探讨了关于n阶格雷码编码方案数的问题。 问题简介 如果将$2^n$个长为n的二进制串组成一个序列,使得将序列按圆形排列时一对相邻的二进制串只有一位不同，则称这些序列为n阶格雷码或简称格雷码(Gray code)。 问不同的n阶格雷码有多少种。 简单分析首先，可以肯定的是，n阶格雷码编码一定是存在的。 在数模电课程给出了一种给出n阶格雷码的简单生成方案，即在n-1阶格雷码复制成两份，前一份在最高位加上0，后一份顺序翻转并在最高位加上一。 考虑对于任意两位，他们的01排布都是不同的，所以任意排列原方案的每一位，就能得到n!种方案，这可以作为该问题的一个下界。 问题结论之后，我尝试通过写程序枚举方案观察性质。我发现有不属于上面提到的n!种方案里任何一种的其它方案，说明这个问题的答案很大。而在思索一番后，也没有找到合适的解决方案。 最后通过网络搜索，我发现该问题是一个经典问题OEISA003042。该问题前六项位：1, 2, 12, 2688, 1813091520, 71676427445141767741440。其中n=6是目前解出的最大n值，解出时间是2010年，并于2012年被验证。","link":"/2024/03/24/%E8%8B%A5%E5%B9%B2%E6%9C%89%E8%B6%A3%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Hexo使用指南","text":"记录常见hexo指令 hexo的优势可以进行搜索找到想要访问的内容 hexo指令在博客的根目录下打开命令提示符，即可执行各类hexo指令。 新建创建名字叫name的文件 1hexo new &quot;name&quot; 清空静态文件清除之前生产的文件 1hexo clean 生成静态文件编辑完成后可以执行此操作，生成本地文件 1hexo generate 可能会有警告出现，可以参考配置（我未配置） 1git config --global core.autocrlf false 有缩写写法 1hexo g 测试本地服务1hexo server 打开本地网络服务即可 之前是service 上传博客最新版本1hexo d","link":"/2023/10/18/Hexo%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/"}],"tags":[],"categories":[],"pages":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hided_posts/hello-world.html"},{"title":"ICPC2024杭州站 E. Period of a String","text":"CCPC-final前vp了去年的杭州站，记录一下这题的分析过程。 link 题目大意字符串A是字符串B的周期串当且仅当B以A为周期，也就是说B是A复制无限次后产生字符串的一个前缀。 现有n个字符串，每个字符串内部可以自由调整字符先后位置，是否有一种调整方案，使得每个串都是后一个串的周期串。 解析","link":"/hided_posts/ICPC2024%E6%9D%AD%E5%B7%9E%E7%AB%99%20E.%20Period%20of%20a%20String.html"},{"title":"n阶格雷码编码方案数问题","text":"OEISA003042问题背景2024-03-13：今天jwong学长和我探讨了关于n阶格雷码编码方案数的问题。 问题简介 如果将$2^n$个长为n的二进制串组成一个序列,使得将序列按圆形排列时一对相邻的二进制串只有一位不同，则称这些序列为n阶格雷码或简称格雷码(Gray code)。 问不同的n阶格雷码有多少种。 初步想法，一个下界首先，可以肯定的是，n阶格雷码编码一定是存在的。 在数模电课程给出了一种给出n阶格雷码的简单生成方案，即在n-1阶格雷码复制成两份，前一份在最高位加上0，后一份顺序翻转并在最高位加上一。 考虑对于任意两位，他们的01排布都是不同的，所以任意排列原方案的每一位，就能得到n!种方案，这可以作为该问题的一个下界。 问题结论之后，我尝试通过写程序枚举方案观察性质。我发现有不属于上面提到的n!种方案里任何一种的其它方案，说明这个问题的答案很大。而在思索一番后，也没有找到合适的解决方案。 最后通过网络搜索，我发现该问题是一个经典问题OEISA003042。该问题前六项位：1, 2, 12, 2688, 1813091520, 71676427445141767741440。其中n=6是目前解出的最大n值，解出时间是2010年，并于2012年被验证。","link":"/hided_posts/n%E9%98%B6%E6%A0%BC%E9%9B%B7%E7%A0%81%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98.html"},{"title":"2024暑期线性代数专题复习","text":"这篇文章将会简单记录线性代数中的知识点，用来在保研夏令营之前进行回顾。","link":"/hided_posts/2024%E6%9A%91%E6%9C%9F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%93%E9%A2%98%E5%A4%8D%E4%B9%A0.html"},{"title":"匈牙利算法与带花树算法","text":"我对理论计算机方向比较感兴趣，最近看到了一篇关于匹配的计算复杂性相关的文章，所以也想以此机会回顾一下匈牙利算法和带花树算法。 二分图最大匹配匈牙利算法枚举每个左边点为其寻找增广路，即如果想匹配的右边点已被匹配，则尝试为该右边点匹配的左边点寻找增广路，这样递归执行直到某一刻找到匹配目标，总复杂度$O(nm)$。 匈牙利算法有两种做法，一种是dfs，一种是bfs，其中bfs的写法强烈建议使用stl的queue，否则会跑的很慢。 网络流解法这个问题也可以用网络流来解，使用Dinic后复杂度为$O(\\sqrt n m)$。 二分图最大权匹配（KM算法）KM算法可以在$O(n^3)$的复杂度内求二分图最大权完美匹配。普通二分图最大权匹配可以加点转换到最大权完美匹配上。 该做法定义了以下几个概念： 可行顶标：给每个节点$i$分配一个权值$l(i)$，对于所有边 $(u,v)$ 满足 $w(u,v) \\leq l(u) + l(v)$。 相等子图：在一组可行顶标下原图的生成子图，包含所有点但只包含满足 $w(u,v) = l(u) + l(v)$ 的边 $(u,v)$。 定理 1 : 对于某组可行顶标，如果其相等子图存在完美匹配，那么，该匹配就是原二分图的最大权完美匹配。 问题就变成了寻找完美匹配可行顶标的问题。 具体做法是在相等子图上做匈牙利算法BFS的最大匹配。如果匹配成功自然是好的，如果匹配失败 一般图最大匹配（带花树算法）一般图最大权匹配参考文献[1]oi-wiki,图论,https://oi-wiki.org/graph/ ,2024年3月16日 [2]Singercoder,【图论】【二分图匹配】匈牙利与km模板,https://www.luogu.com/article/6bpu8vn6 ,2024年3月19日","link":"/hided_posts/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B8%A6%E8%8A%B1%E6%A0%91%E7%AE%97%E6%B3%95.html"},{"title":"近似概率编程初探","text":"最近看到了一篇关于近似概率编程的文章，很有意思，但苦于我在这方面没有只是储备，所以查阅了点资料，简要记下一些概念。 概率编程通俗来讲就是通过一系列给定的概率规则，做出概率运算，这种方法可以被应用于需要面对不确定做出决定的系统。 近似算法随着事实和规则的增加，精确求解较为困难，所以引入近似算法。近似算法主要分为两种，基于边界的近似推理和使用采样的近似推理。 研究层次概率逻辑程序设计语言如何抽象地表达概率语义。 概率逻辑推理类似于剪枝这一类性能优化技巧。 参考文献[1]子推推,近似概率编程文献综述,https://blog.csdn.net/qq_46606829/article/details/123914448,2024年3月16日","link":"/hided_posts/%E8%BF%91%E4%BC%BC%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2.html"}]}