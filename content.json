{"posts":[{"title":"2023JLU_ACM招新面试","text":"吉林大学2023年ACM招新面试于2024年3月9日进行，本次面试采用现场问答题目的形式，目的在于考察同学的解题思路，以下为真题和解析。（题目选择与Hint设计：kingsnow） Codeforces 359B题意给定 $k$ 与 $n$ ，求一个长度为 $2n$ 的排列，满足： 保证 $(1 \\leq n \\leq 50000, 0 \\leq 2k \\leq n)$ Hint1可以先构造特殊情况。 Hint2可以尝试固定最左边这项的取值。 Hint3可以利用等式右边是2k而不是k的性质。 解法特殊情况，指的是 $k=0$时，此时取 $a_t=t$ 即可满足条件。 再考虑 $k\\neq 0$的情况，我们发现当调换 $a_{2i-1}$和 $a_{2i}$且已调换次数较少时，等式左侧的左边一项不变、右边一项会少2。 所以进行$k$次交换，即可构造出题目所需的排列。 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,k;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){ if(k){ k--; printf(&quot;%d %d &quot;,2*i,2*i-1); } else printf(&quot;%d %d &quot;,2*i-1,2*i); } return 0;} Codeforces 1541B题意给定$a_1$~$a_n$ ,保证$a_1$~$a_n$ 两两不同，求pair(i,j)满足 $i&lt;j$且$a_i*a_j=i+j$的对数。 保证$2≤n≤10^5,1≤ai≤2⋅n$ Hint1等式右边的值范围不大。 Hint2$\\sum_{i=1}^n \\frac1i =O(logn)$。 Hint3可先枚举$i$后枚举$i+j$。 解法先枚举$i$，得到$a_i$，那么$i+j$一定是$a_i$的倍数，又可知$i+j\\leq 2n$，所以可以一个一个枚举完$i+j$并验证$a_j$是否符合条件，总复杂度$O(nlogn)$ 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,n,a[100005];int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } int ans=0; for(int i=1;i&lt;=n;i++){ for(int sum=a[i];sum&lt;=2*n;sum+=a[i]){ int j=sum-i; if(j&lt;0||j&gt;n)continue; if(i==j)continue; if((ll)a[i]*a[j]!=sum)continue; ans++; } } printf(&quot;%d\\n&quot;,ans/2); } return 0;} Codeforces 1455B题意你站在坐标轴上的0点，第i次操作你可以选择坐标+i或-1，求到坐标x（x&gt;0）点的最小步数。共t次询问 保证$ 1≤t≤1000,1≤x≤10^6$ Hint1当固定总步数后，可以先走大的再走小的。 Hint2我们可以考虑先全+i，然后反悔 Hint3特殊情况，全取+i时到达了x+1的情况要特殊处理。 解法不断枚举步数，当全取+i时大于等于x了的时候停止。判特殊情况到达x+1，这种情况要加一步。其它情况将对应的步变成-1即可。 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,x;int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;x); int sum=0; for(int i=1;;i++){ sum+=i; if(sum&gt;=x){ if(sum==x+1)printf(&quot;%d\\n&quot;,i+1); else printf(&quot;%d\\n&quot;,i); break; } } } return 0;} Codeforces 1526B题意给x，求x能不能由11,111,1111，。。。，这些数相加得到（数可以重复使用）？共t次询问 保证$ 1≤t≤10000,1≤x≤10^9$ Hint1有些数用不上。 Hint2只有两个数能用上。 Hint3大的数用上的次数是很少的，可以求出来。 解法只有11和111能用上，而111用的次数不超过11次，所以可以直接枚举，或者取模都行。 代码1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,x;int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;x); int b=x%11; if(x&gt;=b*111)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0;}","link":"/2024/03/09/2023JLU_ACM%E6%8B%9B%E6%96%B0%E9%9D%A2%E8%AF%95/"},{"title":"2024上半年JLU_ACM讲题","text":"虽然临近退役，但是既然ACM队的训练需要讲题，还是得把这些题都码一遍，也顺便维持一下思维能力。 第三周训练_习题网址 A - Sasha and the Casino题目大意给定k,x,a，一次打赌赢了本金增加到k倍，输了清零，保证最多输x次，初始资金为a，问是否有策略使得在操作后金额任意大 解法考虑在本问题中，提供的条件不仅包含当前金额，还包含了已经连续输的次数，所以说，我们需要确保当赢了一次之后，金额比之前要高。又考虑到本金有限，所以应该在保证前一条件的情况下，尽可能降低金额的数值。所以在一段连续输后的下一次金额cur=max((cost+k-1)/(k-1),1)其中cost是这一段连续输花钱的总金额。 B - Equalize题目大意给定一个长度为n的数组，要求其与一个排列相加，使得出现次数最多的数的出现次数尽可能大，求这一最大值。 解法对所有数进行排序并去重，问题即变成求最大的满足最大数减最小数的差小于n的区间长度，可以用一个单调队列完成。 C - Physical Education Lesson题目大意1…k..1..k..1依次报数，已知位置n和报数的值x，求可能的k的数量 解法以1…k…2作为一个循环，已知n,x的情况下，循环要么在n-x要么在n+x-2,也有可能同时出现。这样2k-2肯定是循环结束位置的约数，枚举复杂度是根号的。此外还需要保证k不小于x。最后对于所有的k放set去重就可以了。 D - XOR-distance题目大意给定a,b,r，求|(a xor x)-(b xor x)|的最小值，其中$0\\leq x\\leq r$ 解法只需要考虑a,b不同的位，所以其它位都置为0，然后再取两个里大的数，令其最高位为不动，尽量使剩余位都变成0，在满足r的限制下贪心取就能解决此题。 E - A Balanced Problemset?题目大意给一个整数x，要求将x分成n个数的和，使得所有数的最大公因数最大，求这个最大的最大公因数 解法设最大公因数为k，那么k肯定是x的因数，且x/k不能小于x，枚举出满足条件的最大k即可。 F - Did We Get Everything Covered?题目大意给定字符串长度n和字符集k以及一个字符串s，问长度为n的字符集为k的字符串是否都是s的子序列，如果不是，请输出反例。 解法扫一遍，当凑齐一套字符集的字符后开始下一套，一共要n套，如果有责输出yes，不够则可以输出每套最后一个补全的字符和那个缺失的字符。 G - Partitioning the Array题目大意一个长度为$n$的数组a，划分成相等长度的k部分，问存在多少种k，存在m使得所有数模m后，每个部分都相同。 解法合法的k只有$sqrt(n)$个，对于每个k只需要判断是否存在m即可，而m的条件是任意位置相差k的数之差都是m的倍数，所以用gcd即可求得。 H - Watering an Array题目大意一个数组a，第i天可以给数组的前vi个数都加一，也可以选择收获ai=i个点数并清空数组a，其中vi是循环的。问d天后点数最多是多少。 解法容易发现清空数组a后，再收获的时候最多收获1，所以一旦清空最优策略就是加一收获来回进行。所以本题要考虑什么时候第一次收获，容易发现n不大，一次收获最多只有n，而一开始收获则只需要2n天就可以获得n，所以第一次收获一定不晚于2n。枚举时刻取最优就能解决此题。 I - Largest Subsequence题目大意一个字符串，每次选择字典序最大的子序列，将子序列对应位置的字符进行重排，原来最后一个字符到第一个字符的位置上，其它字符均向后移一个字符。问多少次操作，字符串变得有序。 解法考虑先求出最大的子序列（直接扫一遍），然后操作的结果即将这些字符翻转，花的步数即其中不是最大那个字符的字符数量。最后记得判断一下是否有序即可。 J - Array Game题目大意给你一个由$n$个正整数组成的数组$a$。在一次操作中，选取$(i,j)$，将$|a_i-a_j|$加到$a$ 的末尾。要求在执行$k$次操作后，最小化数组$a$的最小值。 解法如果k大于等于3，那么答案为0；如果k=0，答案为最小值；如果k=1，答案还需对差取min；如果k=2，那么答案还需要对两个数的和减去一个数的绝对值的最小值取min。 K - StORage room题目大意现在有一个n*n的表格M，是一把锁。锁的密码是一个长度为n的序列a，满足$M_{i,j}=a_i|a_j$ 解法对于一个a相关的所有要求都取与，再判断这个尽可能大的a是否满足所有条件即可 L - Theofanis’ Nightmare题目大意给定一个数组a,大小为n,现在将数组a分割成几个非空子数组,并且保证每个元素只在一个一个子数组中,例如，数组 [1,−3,7,−6,2,5]可以划分为 [1][−3,7][−6,2][5]。这种分割的值等于第i个子数组的和乘以i，再求和。求分割的最大值。 解法考虑一次划分后面的所有数贡献都加一，所以只需要找到大于等于0的后缀并且都加一即可，特判第一个位置。","link":"/2024/03/13/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4JLU_ACM%E8%AE%B2%E9%A2%98/"},{"title":"Hexo使用指南","text":"记录常见hexo指令 hexo的优势可以进行搜索找到想要访问的内容 hexo指令在博客的根目录下打开命令提示符，即可执行各类hexo指令。 新建创建名字叫name的文件 1hexo new &quot;name&quot; 清空静态文件清除之前生产的文件 1hexo clean 生成静态文件编辑完成后可以执行此操作，生成本地文件 1hexo generate 可能会有警告出现，可以参考配置（我未配置） 1git config --global core.autocrlf false 有缩写写法 1hexo g 测试本地服务1hexo server 打开本地网络服务即可 之前是service 上传博客最新版本1hexo d","link":"/2023/10/18/Hexo%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/"},{"title":"若干有趣的问题","text":"最近时常碰到一些有趣的问题，在这里记录一下我对这些问题的初步想法和在网上搜到的资料 OEISA004125问题背景2024.3.24:今天vp的时候碰到相关的题目分析复杂度时想到的。 问题简介一个正整数对小于等于自己当前值的正整数取模，结果的的期望是多少。该问题也就是求n分之一的下式：$$f(n)=\\sum_{i=1}^n (n\\bmod i)$$ 简单分析一次取模后，值不足原来的一半，所以有一个$\\frac{n^2}2$的上界；这个结论也可以通过余数不会大于除数而求和得到。 问题结论事实上，有一个等式把该问题进行转换：$$\\sum_{i=1}^n (n\\bmod i)=n^2-\\sum_{i=1}^n\\sigma(i)$$其中$\\sigma$是除数和函数。 这个式子证明大概可以按照如下思路，对于每个$(n\\bmod i)$，$i$作为除数出现在$i,2i,3i…$中，出现的次数恰好等于$\\left\\lfloor\\frac ni\\right\\rfloor$，这个次数乘以$i$后刚好等于$n$减去余数。 而除数和函数是积性函数，可以多项式复杂度内求解。 该数列本身的更多信息可参见oeis。 参考资料Jeffrey Shallit,Answer,2024.3.24 拓展问题一个正整数对小于等于自己当前值的正整数取模，需要多少次操作才能变成0 最坏情况每次$n_i$都对$\\left\\lceil \\frac{n_i+1}2\\right\\rceil$取模，当$n$处于$1$到$10^8$的范围内时，需要的次数大约在$1.4log_2(n)$左右。 期望情况根据该数列的信息，我猜测期望仍然是$O(log_2(n))$的。 OEISA003042问题背景2024-03-13：今天jwong学长和我探讨了关于n阶格雷码编码方案数的问题。 问题简介 如果将$2^n$个长为n的二进制串组成一个序列,使得将序列按圆形排列时一对相邻的二进制串只有一位不同，则称这些序列为n阶格雷码或简称格雷码(Gray code)。 问不同的n阶格雷码有多少种。 简单分析首先，可以肯定的是，n阶格雷码编码一定是存在的。 在数模电课程给出了一种给出n阶格雷码的简单生成方案，即在n-1阶格雷码复制成两份，前一份在最高位加上0，后一份顺序翻转并在最高位加上一。 考虑对于任意两位，他们的01排布都是不同的，所以任意排列原方案的每一位，就能得到n!种方案，这可以作为该问题的一个下界。 问题结论之后，我尝试通过写程序枚举方案观察性质。我发现有不属于上面提到的n!种方案里任何一种的其它方案，说明这个问题的答案很大。而在思索一番后，也没有找到合适的解决方案。 最后通过网络搜索，我发现该问题是一个经典问题OEISA003042。该问题前六项位：1, 2, 12, 2688, 1813091520, 71676427445141767741440。其中n=6是目前解出的最大n值，解出时间是2010年，并于2012年被验证。","link":"/2024/03/24/%E8%8B%A5%E5%B9%B2%E6%9C%89%E8%B6%A3%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"利用同磁盘下其它分区扩容C盘","text":"记录一次C盘扩容 背景条件操作系统：Windows 11 电脑配置：一块500GB固态硬盘（C盘200GB，D盘300GB）和一块500GB机械硬盘（E盘），外接1TB固态硬盘。 主要诉求：电脑存储空间足够，但系统盘C盘的200GB快用完了，需要扩容。 操作步骤打开磁盘管理右键“此电脑”，点击管理，在出现的“计算机管理”界面中点击磁盘管理。 清理同磁盘下的其它分区为了扩容C盘，需要对同一硬盘上的另一个分区D盘进行清理和格式化。 具体步骤包括卸载软件和备份文件。 剩余一些文件的处理（危险操作）由于D盘有些内容需要保留，我选择将这些文件移到外接固态硬盘中，然后重新分配D盘的空间，并将文件移回D盘。 事实证明，这是一项危险操作，复制粘贴过程中可能会丢失文件。例如，我在操作过程中导致搜狗输入法崩溃，不得不重新安装。 格式化清理完文件后，格式化D盘并删除卷，然后分配一部分空间给C盘。本次扩容将C盘的空间增加至400GB。 移回剩余部分将D盘重新组织成较小的分区，并将原有内容还原到新的D盘中。 更改盘符名在磁盘管理界面，右键点击要修改的分区，选择“更改驱动器号和路径”，点击“更改”，并选择新的驱动器号。 总结通过上述步骤，C盘成功从200GB扩容至400GB，但在处理D盘时出现了一些问题，导致部分软件崩溃需要重新安装。未来可能会出现未知错误。可能以后在操作前需要备份所有重要数据，或者使用专业的分区管理软件以确保数据安全。","link":"/2024/08/02/%E5%88%A9%E7%94%A8%E5%90%8C%E7%A3%81%E7%9B%98%E4%B8%8B%E5%85%B6%E5%AE%83%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9C%E7%9B%98/"},{"title":"引用管理指南","text":"","link":"/2024/08/28/%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86%E6%8C%87%E5%8D%97/"}],"tags":[],"categories":[],"pages":[]}