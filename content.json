{"posts":[{"title":"2023JLU_ACM招新面试","text":"吉林大学2023年ACM招新面试于2024年3月9日进行，本次面试采用现场问答题目的形式，目的在于考察同学的解题思路，以下为真题和解析。（题目选择与Hint设计：kingsnow） Codeforces 359B题意给定 $k$ 与 $n$ ，求一个长度为 $2n$ 的排列，满足： 保证 $(1 \\leq n \\leq 50000, 0 \\leq 2k \\leq n)$ Hint1可以先构造特殊情况。 Hint2可以尝试固定最左边这项的取值。 Hint3可以利用等式右边是2k而不是k的性质。 解法特殊情况，指的是 $k=0$时，此时取 $a_t=t$ 即可满足条件。 再考虑 $k\\neq 0$的情况，我们发现当调换 $a_{2i-1}$和 $a_{2i}$且已调换次数较少时，等式左侧的左边一项不变、右边一项会少2。 所以进行$k$次交换，即可构造出题目所需的排列。 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,k;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){ if(k){ k--; printf(&quot;%d %d &quot;,2*i,2*i-1); } else printf(&quot;%d %d &quot;,2*i-1,2*i); } return 0;} Codeforces 1541B题意给定$a_1$~$a_n$ ,保证$a_1$~$a_n$ 两两不同，求pair(i,j)满足 $i&lt;j$且$a_i*a_j=i+j$的对数。 保证$2≤n≤10^5,1≤ai≤2⋅n$ Hint1等式右边的值范围不大。 Hint2$\\sum_{i=1}^n \\frac1i =O(logn)$。 Hint3可先枚举$i$后枚举$i+j$。 解法先枚举$i$，得到$a_i$，那么$i+j$一定是$a_i$的倍数，又可知$i+j\\leq 2n$，所以可以一个一个枚举完$i+j$并验证$a_j$是否符合条件，总复杂度$O(nlogn)$ 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,n,a[100005];int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } int ans=0; for(int i=1;i&lt;=n;i++){ for(int sum=a[i];sum&lt;=2*n;sum+=a[i]){ int j=sum-i; if(j&lt;0||j&gt;n)continue; if(i==j)continue; if((ll)a[i]*a[j]!=sum)continue; ans++; } } printf(&quot;%d\\n&quot;,ans/2); } return 0;} Codeforces 1455B题意你站在坐标轴上的0点，第i次操作你可以选择坐标+i或-1，求到坐标x（x&gt;0）点的最小步数。共t次询问 保证$ 1≤t≤1000,1≤x≤10^6$ Hint1当固定总步数后，可以先走大的再走小的。 Hint2我们可以考虑先全+i，然后反悔 Hint3特殊情况，全取+i时到达了x+1的情况要特殊处理。 解法不断枚举步数，当全取+i时大于等于x了的时候停止。判特殊情况到达x+1，这种情况要加一步。其它情况将对应的步变成-1即可。 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,x;int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;x); int sum=0; for(int i=1;;i++){ sum+=i; if(sum&gt;=x){ if(sum==x+1)printf(&quot;%d\\n&quot;,i+1); else printf(&quot;%d\\n&quot;,i); break; } } } return 0;} Codeforces 1526B题意给x，求x能不能由11,111,1111，。。。，这些数相加得到（数可以重复使用）？共t次询问 保证$ 1≤t≤10000,1≤x≤10^9$ Hint1有些数用不上。 Hint2只有两个数能用上。 Hint3大的数用上的次数是很少的，可以求出来。 解法只有11和111能用上，而111用的次数不超过11次，所以可以直接枚举，或者取模都行。 代码1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,x;int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;x); int b=x%11; if(x&gt;=b*111)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0;}","link":"/2024/03/09/2023JLU_ACM%E6%8B%9B%E6%96%B0%E9%9D%A2%E8%AF%95/"},{"title":"2024上半年JLU_ACM讲题","text":"虽然临近退役，但是既然ACM队的训练需要讲题，还是得把这些题都码一遍，也顺便维持一下思维能力。 第三周训练_习题网址 A - Sasha and the Casino题目大意给定k,x,a，一次打赌赢了本金增加到k倍，输了清零，保证最多输x次，初始资金为a，问是否有策略使得在操作后金额任意大 解法考虑在本问题中，提供的条件不仅包含当前金额，还包含了已经连续输的次数，所以说，我们需要确保当赢了一次之后，金额比之前要高。又考虑到本金有限，所以应该在保证前一条件的情况下，尽可能降低金额的数值。所以在一段连续输后的下一次金额cur=max((cost+k-1)/(k-1),1)其中cost是这一段连续输花钱的总金额。 B - Equalize题目大意给定一个长度为n的数组，要求其与一个排列相加，使得出现次数最多的数的出现次数尽可能大，求这一最大值。 解法对所有数进行排序并去重，问题即变成求最大的满足最大数减最小数的差小于n的区间长度，可以用一个单调队列完成。 C - Physical Education Lesson题目大意1…k..1..k..1依次报数，已知位置n和报数的值x，求可能的k的数量 解法以1…k…2作为一个循环，已知n,x的情况下，循环要么在n-x要么在n+x-2,也有可能同时出现。这样2k-2肯定是循环结束位置的约数，枚举复杂度是根号的。此外还需要保证k不小于x。最后对于所有的k放set去重就可以了。 D - XOR-distance题目大意给定a,b,r，求|(a xor x)-(b xor x)|的最小值，其中$0\\leq x\\leq r$ 解法只需要考虑a,b不同的位，所以其它位都置为0，然后再取两个里大的数，令其最高位为不动，尽量使剩余位都变成0，在满足r的限制下贪心取就能解决此题。 E - A Balanced Problemset?题目大意给一个整数x，要求将x分成n个数的和，使得所有数的最大公因数最大，求这个最大的最大公因数 解法设最大公因数为k，那么k肯定是x的因数，且x/k不能小于x，枚举出满足条件的最大k即可。 F - Did We Get Everything Covered?题目大意给定字符串长度n和字符集k以及一个字符串s，问长度为n的字符集为k的字符串是否都是s的子序列，如果不是，请输出反例。 解法扫一遍，当凑齐一套字符集的字符后开始下一套，一共要n套，如果有责输出yes，不够则可以输出每套最后一个补全的字符和那个缺失的字符。 G - Partitioning the Array题目大意一个长度为$n$的数组a，划分成相等长度的k部分，问存在多少种k，存在m使得所有数模m后，每个部分都相同。 解法合法的k只有$sqrt(n)$个，对于每个k只需要判断是否存在m即可，而m的条件是任意位置相差k的数之差都是m的倍数，所以用gcd即可求得。 H - Watering an Array题目大意一个数组a，第i天可以给数组的前vi个数都加一，也可以选择收获ai=i个点数并清空数组a，其中vi是循环的。问d天后点数最多是多少。 解法容易发现清空数组a后，再收获的时候最多收获1，所以一旦清空最优策略就是加一收获来回进行。所以本题要考虑什么时候第一次收获，容易发现n不大，一次收获最多只有n，而一开始收获则只需要2n天就可以获得n，所以第一次收获一定不晚于2n。枚举时刻取最优就能解决此题。 I - Largest Subsequence题目大意一个字符串，每次选择字典序最大的子序列，将子序列对应位置的字符进行重排，原来最后一个字符到第一个字符的位置上，其它字符均向后移一个字符。问多少次操作，字符串变得有序。 解法考虑先求出最大的子序列（直接扫一遍），然后操作的结果即将这些字符翻转，花的步数即其中不是最大那个字符的字符数量。最后记得判断一下是否有序即可。 J - Array Game题目大意给你一个由$n$个正整数组成的数组$a$。在一次操作中，选取$(i,j)$，将$|a_i-a_j|$加到$a$ 的末尾。要求在执行$k$次操作后，最小化数组$a$的最小值。 解法如果k大于等于3，那么答案为0；如果k=0，答案为最小值；如果k=1，答案还需对差取min；如果k=2，那么答案还需要对两个数的和减去一个数的绝对值的最小值取min。 K - StORage room题目大意现在有一个n*n的表格M，是一把锁。锁的密码是一个长度为n的序列a，满足$M_{i,j}=a_i|a_j$ 解法对于一个a相关的所有要求都取与，再判断这个尽可能大的a是否满足所有条件即可 L - Theofanis’ Nightmare题目大意给定一个数组a,大小为n,现在将数组a分割成几个非空子数组,并且保证每个元素只在一个一个子数组中,例如，数组 [1,−3,7,−6,2,5]可以划分为 [1][−3,7][−6,2][5]。这种分割的值等于第i个子数组的和乘以i，再求和。求分割的最大值。 解法考虑一次划分后面的所有数贡献都加一，所以只需要找到大于等于0的后缀并且都加一即可，特判第一个位置。","link":"/2024/03/13/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4JLU_ACM%E8%AE%B2%E9%A2%98/"},{"title":"Hexo使用指南","text":"记录常用的Hexo指令 执行Hexo指令在博客的根目录下运行命令提示符，便能执行各类hexo指令。 新建文件创建一个名为name的文件。 1hexo new &quot;name&quot; 清理静态文件清理此前生成的静态文件(即博客中展示的页面)。 1hexo clean 生成静态文件完成博客编辑后，执行此操作以生成本地静态文件。 1hexo generate 也可以使用简写命令 1hexo g 测试本地服务1hexo server 可通过打开本地网络服务，查看显示情况。 以前的版本此处可能是service 部署静态文件至云端1hexo d","link":"/2023/10/18/Hexo%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/"},{"title":"利用同磁盘下其它分区扩容C盘","text":"记录一次C盘扩容 背景条件操作系统：Windows 11 电脑配置：一块500GB固态硬盘（C盘200GB，D盘300GB）和一块500GB机械硬盘（E盘），外接1TB固态硬盘。 主要诉求：电脑存储空间足够，但系统盘C盘的200GB快用完了，需要扩容。 操作步骤打开磁盘管理右键“此电脑”，点击管理，在出现的“计算机管理”界面中点击磁盘管理。 清理同磁盘下的其它分区为了扩容C盘，需要对同一硬盘上的另一个分区D盘进行清理和格式化。 具体步骤包括卸载软件和备份文件。 剩余一些文件的处理（危险操作）由于D盘有些内容需要保留，我选择将这些文件移到外接固态硬盘中，然后重新分配D盘的空间，并将文件移回D盘。 事实证明，这是一项危险操作，复制粘贴过程中可能会丢失文件。例如，我在操作过程中导致搜狗输入法崩溃，不得不重新安装。 格式化清理完文件后，格式化D盘并删除卷，然后分配一部分空间给C盘。本次扩容将C盘的空间增加至400GB。 移回剩余部分将D盘重新组织成较小的分区，并将原有内容还原到新的D盘中。 更改盘符名在磁盘管理界面，右键点击要修改的分区，选择“更改驱动器号和路径”，点击“更改”，并选择新的驱动器号。 总结通过上述步骤，C盘成功从200GB扩容至400GB，但在处理D盘时出现了一些问题，导致部分软件崩溃需要重新安装。未来可能会出现未知错误。可能以后在操作前需要备份所有重要数据，或者使用专业的分区管理软件以确保数据安全。","link":"/2024/08/02/%E5%88%A9%E7%94%A8%E5%90%8C%E7%A3%81%E7%9B%98%E4%B8%8B%E5%85%B6%E5%AE%83%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9C%E7%9B%98/"},{"title":"Tutte多项式","text":"导说这是很著名的概念，所以在这里简单记录一下。 内容参考自《Handbook of the Tutte Polynomial and Related Topics》，并添加了一些我的理解，学艺不精请大伙多多包涵。 秩和环度对于图$G=(V,E)$，下表给出了一些基本量： 符号 含义 性质 $k(G)$ 连通块数量 $v(G)$ 图$G$的顶点数 $e(G)$ 图$G$的边数 $r(G)$ 秩 $r(G):=v(G)-k(G)$ $n(G)$ 环度（nullity） $n(G):=e(G)-r(G)=e(G)-v(G)+k(G)$ $f(A),A\\subseteq E$ 用边集代替对应生成子图作为参数 $f(A)=f(G(V,A))$ $r(E)-r(A)$ 余秩（corank） $r(G)$可以理解为“图的生成森林的最大边数”，相应$n(G)$就可以理解成其余的边。 为了进一步理解，下面列出了对图$G$的操作与这两个变量取值的关联： ​ 加孤立顶点：$r(G),n(G)$都不变； ​ 加边且不改变连通块数量：$r(G)$不变，$n(G)$增加$1$； ​ 加边使若连通块数量减少$1$：$r(G)$增加$1$，$n(G)$不变。 Tutte多项式定义：$T(G;x,y)=\\sum_{A \\subseteq E}(x-1)^{r(E)-r(A)}(y-1)^{n(A)}$，其中 这是一个整系数多项式，即$T(G;x,y)\\in\\mathbb Z[x,y]$。 Tutte多项式枚举了所有边集的子集。 表达式的两个指数上分别是余秩和环度。 余秩对应生成子图与原图的连通块数量的差值。 $T(G;x,y)=\\sum_{A \\subseteq E}(x-1)^{k(A)-k(E)}(y-1)^{n(A)}$ Whitney秩生成函数定义：$W(G;x,y)=T(G;x+1,y+1)$ $W(G;x,y)=\\sum_{A \\subseteq E}x^{r(E)-r(A)}y^{n(A)}$ 二色多项式(dichromatic polynomial)定义：$Z(G;u,v)=\\sum_{A \\subseteq E(G)} u^{k(A)} v^{e(A)}$ Tutte多项式、二色多项式、Whitney秩生成函数之间的关联$T(G;x,y)=(x-1)^{-k(G)}(y-1)^{-v(G)}Z(G;(x-1)(y-1),(y-1))$ 重写Whitney秩生成函数可以得到$W(G;x,y)=\\sum_{A \\subseteq E}x^{r(E)-r(A)}y^{n(A)}=x^{-k(G)}y^{-v(G)}\\sum_{A \\subseteq E}x^{k(A)}y^{e(A)+k(A)}$，这个形式与二色多项式非常相似，不同点在于提出的与$A$无关的部分，以及在$x,y$的指数上同时出现的$k(A)$。 代入$u=xy,v=y$可以得到$Z(G;xy,y)=\\sum_{A \\subseteq E}x^{k(A)}y^{e(A)+k(A)}$。 即$W(G;x,y)=x^{-k(G)}y^{-v(G)}Z(G;xy,y)$。 对于Tutte多项式与二色多项式只需要联立Whitney秩生成函数的定义即可：$T(G;x,y)=(x-1)^{-k(G)}(y-1)^{-v(G)}Z(G;(x-1)(y-1),(y-1))$。","link":"/2025/10/28/Tutte%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"title":"BibTex引用管理指南","text":"记录用BibTex管理引用的方法。 BibTex能够收纳所有读过的论文，并且能有效降低LaTex写作时的工作量。 前置环境Win11，需要安装LaTex，并在Vscode配好LaTex的自动编译。 使用方法在找论文时，一般可以点击Cite-Export citation to BibTex就可以得到一段代码或者一个.bib文件。 比如 12345678910111213141516171819202122@article{ZHANG2024107518,title = {Are your apps accessible? A GCN-based accessibility checker for low vision users},journal = {Information and Software Technology},volume = {174},pages = {107518},year = {2024},issn = {0950-5849},doi = {https://doi.org/10.1016/j.infsof.2024.107518},url = {https://www.sciencedirect.com/science/article/pii/S095058492400123X},author = {Mengxi Zhang and Huaxiao Liu and Shenning Song and Chunyang Chen and Pei Huang and Jian Zhao},keywords = {GUI, Accessibility, Graph convolutional neural networks, Low vision users},abstract = {Context:Accessibility issues (e.g., small size and narrow interval) in mobile applications (apps) lead to obstacles for billions of low vision users in interacting with Graphical User Interfaces (GUIs). Although GUI accessibility scanning tools exist, most of them perform rule-based check relying on complex GUI hierarchies. This might make them detect invisible redundant information, cannot handle small deviations, omit similar components, and is hard to extend.Objective:In this paper, we propose a novel approach, named ALVIN (Accessibility Checker for Low Vision), which represents the GUI as a graph and adopts the Graph Convolutional Neural Networks (GCN) to label inaccessible components.Method:ALVIN removes invisible views to prevent detecting redundancy and uses annotations from low vision users to handle small deviations. Also, the GCN model could consider the relations between GUI components, connecting similar components and reducing the possibility of omission. ALVIN only requires users to annotate the relevant dataset when detecting new kinds of issues.Results:Our experiments on 48 apps demonstrate the effectiveness of ALVIN, with precision of 83.5%, recall of 78.9%, and F1-score of 81.2%, outperforming baseline methods. In RQ2, the usefulness is verified through 20 issues submitted to open-source apps. The RQ3 also illustrates the GCN model is better than other models.Conclusion:To summarize, our proposed approach can effectively detect accessibility issues in GUIs for low vision users, thereby guiding developers in fixing them efficiently.}} 建议将需要使用的引用都放入一个ref.bib中，每个article之间用空行隔开。 接下来，在LaTex写作过程中，可以把ref.bib拖到同一目录下，并用如下方式引用： 1234567891011\\documentclass{article}\\usepackage{cite}\\begin{document}Hello, LaTeX! \\cite{ZHANG2024107518}\\bibliography{ref}\\bibliographystyle{ieeetr}\\end{document} 需要执行如下编译操作 1234LaTex 文件名（不含后缀）BibTex 文件名（不含后缀）LaTex 文件名（不含后缀）LaTex 文件名（不含后缀） 在Vscode中也可以通过保存来完成一次LaTex，但BibTex似乎只能通过命令行完成。 参考[1]VSCode+latex引用bibtex参考文献_vscode 使用latex bib-CSDN博客","link":"/2024/08/28/%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86%E6%8C%87%E5%8D%97/"},{"title":"若干有趣的问题","text":"最近时常碰到一些有趣的问题，在这里记录一下我对这些问题的初步想法和在网上搜到的资料 OEISA004125问题背景2024.3.24:今天vp的时候碰到相关的题目分析复杂度时想到的。 问题简介一个正整数对小于等于自己当前值的正整数取模，结果的的期望是多少。该问题也就是求n分之一的下式：$$f(n)=\\sum_{i=1}^n (n\\bmod i)$$ 简单分析一次取模后，值不足原来的一半，所以有一个$\\frac{n^2}2$的上界；这个结论也可以通过余数不会大于除数而求和得到。 问题结论事实上，有一个等式把该问题进行转换：$$\\sum_{i=1}^n (n\\bmod i)=n^2-\\sum_{i=1}^n\\sigma(i)$$其中$\\sigma$是除数和函数。 这个式子证明大概可以按照如下思路，对于每个$(n\\bmod i)$，$i$作为除数出现在$i,2i,3i…$中，出现的次数恰好等于$\\left\\lfloor\\frac ni\\right\\rfloor$，这个次数乘以$i$后刚好等于$n$减去余数。 而除数和函数是积性函数，可以多项式复杂度内求解。 该数列本身的更多信息可参见oeis。 参考资料Jeffrey Shallit,Answer,2024.3.24 拓展问题一个正整数对小于等于自己当前值的正整数取模，需要多少次操作才能变成0 最坏情况每次$n_i$都对$\\left\\lceil \\frac{n_i+1}2\\right\\rceil$取模，当$n$处于$1$到$10^8$的范围内时，需要的次数大约在$1.4log_2(n)$左右。 期望情况根据该数列的信息，我猜测期望仍然是$O(log_2(n))$的。 OEISA003042问题背景2024-03-13：今天jwong学长和我探讨了关于n阶格雷码编码方案数的问题。 问题简介 如果将$2^n$个长为n的二进制串组成一个序列,使得将序列按圆形排列时一对相邻的二进制串只有一位不同，则称这些序列为n阶格雷码或简称格雷码(Gray code)。 问不同的n阶格雷码有多少种。 简单分析首先，可以肯定的是，n阶格雷码编码一定是存在的。 在数模电课程给出了一种给出n阶格雷码的简单生成方案，即在n-1阶格雷码复制成两份，前一份在最高位加上0，后一份顺序翻转并在最高位加上一。 考虑对于任意两位，他们的01排布都是不同的，所以任意排列原方案的每一位，就能得到n!种方案，这可以作为该问题的一个下界。 问题结论之后，我尝试通过写程序枚举方案观察性质。我发现有不属于上面提到的n!种方案里任何一种的其它方案，说明这个问题的答案很大。而在思索一番后，也没有找到合适的解决方案。 最后通过网络搜索，我发现该问题是一个经典问题OEISA003042。该问题前六项位：1, 2, 12, 2688, 1813091520, 71676427445141767741440。其中n=6是目前解出的最大n值，解出时间是2010年，并于2012年被验证。","link":"/2024/03/24/%E8%8B%A5%E5%B9%B2%E6%9C%89%E8%B6%A3%E7%9A%84%E9%97%AE%E9%A2%98/"}],"tags":[],"categories":[],"pages":[{"title":"About Me","text":"About MeI am Yuheng Zhou(周宇恒), currently a Ph.D. student in Theoretical Computer Science at Nanjing University, advised by Jingcheng Liu.My research focuses on graph algorithms, differential privacy, and combinatorial optimization. 🎓 Education Ph.D. in Computer Science, Nanjing University, 2025 – present B.S. in Computer Science, Jilin University, 2025 💬 Contact Email: 1287121642@qq.com GitHub: zhouyuheng2003 Google Scholar: ‪Yuheng Zhou‬ - ‪Google Scholar‬","link":"/about/index.html"}]}