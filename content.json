{"posts":[{"title":"2023JLU_ACM招新面试","text":"吉林大学2023年ACM招新面试于2024年3月9日进行，本次面试采用现场问答题目的形式，目的在于考察同学的解题思路，以下为真题和解析。（题目选择与Hint设计：kingsnow） Codeforces 359B题意给定 $k$ 与 $n$ ，求一个长度为 $2n$ 的排列，满足： 保证 $(1 \\leq n \\leq 50000, 0 \\leq 2k \\leq n)$ Hint1可以先构造特殊情况。 Hint2可以尝试固定最左边这项的取值。 Hint3可以利用等式右边是2k而不是k的性质。 解法特殊情况，指的是 $k=0$时，此时取 $a_t=t$ 即可满足条件。 再考虑 $k\\neq 0$的情况，我们发现当调换 $a_{2i-1}$和 $a_{2i}$且已调换次数较少时，等式左侧的左边一项不变、右边一项会少2。 所以进行$k$次交换，即可构造出题目所需的排列。 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,k;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){ if(k){ k--; printf(&quot;%d %d &quot;,2*i,2*i-1); } else printf(&quot;%d %d &quot;,2*i-1,2*i); } return 0;} Codeforces 1541B题意给定$a_1$~$a_n$ ,保证$a_1$~$a_n$ 两两不同，求pair(i,j)满足 $i&lt;j$且$a_i*a_j=i+j$的对数。 保证$2≤n≤10^5,1≤ai≤2⋅n$ Hint1等式右边的值范围不大。 Hint2$\\sum_{i=1}^n \\frac1i =O(logn)$。 Hint3可先枚举$i$后枚举$i+j$。 解法先枚举$i$，得到$a_i$，那么$i+j$一定是$a_i$的倍数，又可知$i+j\\leq 2n$，所以可以一个一个枚举完$i+j$并验证$a_j$是否符合条件，总复杂度$O(nlogn)$ 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,n,a[100005];int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } int ans=0; for(int i=1;i&lt;=n;i++){ for(int sum=a[i];sum&lt;=2*n;sum+=a[i]){ int j=sum-i; if(j&lt;0||j&gt;n)continue; if(i==j)continue; if((ll)a[i]*a[j]!=sum)continue; ans++; } } printf(&quot;%d\\n&quot;,ans/2); } return 0;} Codeforces 1455B题意你站在坐标轴上的0点，第i次操作你可以选择坐标+i或-1，求到坐标x（x&gt;0）点的最小步数。共t次询问 保证$ 1≤t≤1000,1≤x≤10^6$ Hint1当固定总步数后，可以先走大的再走小的。 Hint2我们可以考虑先全+i，然后反悔 Hint3特殊情况，全取+i时到达了x+1的情况要特殊处理。 解法不断枚举步数，当全取+i时大于等于x了的时候停止。判特殊情况到达x+1，这种情况要加一步。其它情况将对应的步变成-1即可。 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,x;int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;x); int sum=0; for(int i=1;;i++){ sum+=i; if(sum&gt;=x){ if(sum==x+1)printf(&quot;%d\\n&quot;,i+1); else printf(&quot;%d\\n&quot;,i); break; } } } return 0;} Codeforces 1526B题意给x，求x能不能由11,111,1111，。。。，这些数相加得到（数可以重复使用）？共t次询问 保证$ 1≤t≤10000,1≤x≤10^9$ Hint1有些数用不上。 Hint2只有两个数能用上。 Hint3大的数用上的次数是很少的，可以求出来。 解法只有11和111能用上，而111用的次数不超过11次，所以可以直接枚举，或者取模都行。 代码1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t,x;int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d&quot;,&amp;x); int b=x%11; if(x&gt;=b*111)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0;}","link":"/2024/03/09/2023JLU_ACM%E6%8B%9B%E6%96%B0%E9%9D%A2%E8%AF%95/"}],"tags":[],"categories":[],"pages":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hided_posts/hello-world.html"}]}